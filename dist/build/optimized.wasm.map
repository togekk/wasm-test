{"version":3,"sources":["~lib/internal/allocator.ts","~lib/allocator/arena.ts","assembly/index.ts","~lib/string.ts","~lib/internal/string.ts","~lib/memory.ts"],"names":[],"mappings":"wJCgBE,AAAI,IACF,AAAI,EAAO,SAAa,EAIxB,AAAI,AAFJ,AAAa,AAAC,AADd,AAAU,IACU,GAAO,QAEd,AADb,AAAkB,IACiB,MAGjC,AAAI,AADc,AAAI,EADtB,AAAkB,AAAC,AAAC,EAAS,GAAM,UAAuB,eAE3B,KAAG,AAC5B,AAAY,IAAe,KAAG,IAKtC,AAAS,IACF,IAEF,KAUP,AAAS,OIoNT,AAAI,EAAM,KAAW,MACd,IAAK,AAAS,KAAO,AAAS,YACnC,OACA,OACA,WAEiD,AAA5C,IAAI,AAAc,KAAM,AAAc,OAAM,QFpJjD,AAAI,EAAS,KAAc,IAC3B,AAAI,UAAiB,MAAuB,IAG5C,AAAI,AADJ,AAAiB,OACC,QAAqB,IAMvC,AAJQ,AACN,EAA0B,GAC1B,EAA2B,GAC3B,AAAC,EAAqB,WDhH1B,EAAK,AAAQ,MAAS,EAAI,EAAU,EAAM,OACxC,AAAY,IACZ,EAAK,AAAQ,MAAU,EAAI,EAAW,EAAO,OAE3C,AAAI,EADS,MACI,AACR,IAHsC,EAAK,YAFV,EAAK,UAS5C,KDRgB,AAAC,EAAY,QAClB","sourceRoot":"assemblyscript:///","sourceContents":["/** Number of alignment bits. */\r\nexport const AL_BITS: u32 = 3;\r\n\r\n/** Number of possible alignment values. */\r\nexport const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n\r\n/** Mask to obtain just the alignment bits. */\r\nexport const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n/** Maximum 32-bit allocation size. */\r\nexport const MAX_SIZE_32: usize = 1 << 30; // 1GB\r\n","/**\r\n * Arena Memory Allocator\r\n *\r\n * Provides a `reset_memory` function to reset the heap to its initial state. A user has to make\r\n * sure that there are no more references to cleared memory afterwards. Always aligns to 8 bytes.\r\n *\r\n * @module std/assembly/allocator/arena\r\n *//***/\r\n\r\nimport { AL_MASK, MAX_SIZE_32 } from \"../internal/allocator\";\r\n\r\nvar startOffset: usize = (HEAP_BASE + AL_MASK) & ~AL_MASK;\r\nvar offset: usize = startOffset;\r\n\r\n@global\r\nexport function allocate_memory(size: usize): usize {\r\n  if (size) {\r\n    if (size > MAX_SIZE_32) unreachable();\r\n    let ptr = offset;\r\n    let newPtr = (ptr + size + AL_MASK) & ~AL_MASK;\r\n    let pagesBefore = current_memory();\r\n    if (newPtr > <usize>pagesBefore << 16) {\r\n      let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\r\n      let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n      if (grow_memory(pagesWanted) < 0) {\r\n        if (grow_memory(pagesNeeded) < 0) {\r\n          unreachable(); // out of memory\r\n        }\r\n      }\r\n    }\r\n    offset = newPtr;\r\n    return ptr;\r\n  }\r\n  return 0;\r\n}\r\n\r\n@global\r\nexport function free_memory(ptr: usize): void {\r\n  // nop\r\n}\r\n\r\n@global\r\nexport function reset_memory(): void {\r\n  offset = startOffset;\r\n}\r\n","// The entry file of your WebAssembly module.\nimport \"allocator/arena\";\nexport { allocate_memory, reset_memory };\n\n// export function log(): Array<string> {\n//   const a: Array<string> = ['John', 'Carl', 'Felix', 'Gavin', 'Hayley'];\n//   return a;\n// }\n\nexport function compare_string(arr_ptr: i32, arr_ptr2: i32, len: i32, len2: i32): i32 {\n  for (let i = arr_ptr; i < arr_ptr + len * 16; i += 16) {\n    const str = changetype<string>(i);\n    for (let j = arr_ptr2; j < arr_ptr2 + len2 * 16; j += 16) {\n      const str2 = changetype<string>(j);\n      if (str == str2) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n\n\n  // const str: string = changetype<string>(ptr);\n  // const str2: string = changetype<string>(ptr2);\n  // return str == str2;\n}","import {\r\n  HEADER_SIZE,\r\n  MAX_LENGTH,\r\n  EMPTY,\r\n  clamp,\r\n  allocate,\r\n  isWhiteSpaceOrLineTerminator,\r\n  CharCode,\r\n  parse\r\n} from \"./internal/string\";\r\n\r\n@sealed\r\nexport class String {\r\n\r\n  readonly length: i32; // capped to [0, MAX_LENGTH]\r\n\r\n  @operator(\"[]\")\r\n  charAt(pos: i32): String {\r\n    assert(this !== null);\r\n\r\n    if (<u32>pos >= <u32>this.length) {\r\n      return EMPTY;\r\n    }\r\n\r\n    var out = allocate(1);\r\n    store<u16>(\r\n      changetype<usize>(out),\r\n      load<u16>(\r\n        changetype<usize>(this) + (<usize>pos << 1),\r\n        HEADER_SIZE\r\n      ),\r\n      HEADER_SIZE\r\n    );\r\n    return out;\r\n  }\r\n\r\n  charCodeAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) {\r\n      return -1; // (NaN)\r\n    }\r\n    return load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n  }\r\n\r\n  codePointAt(pos: i32): i32 {\r\n    assert(this !== null);\r\n    if (<u32>pos >= <u32>this.length) {\r\n      return -1; // (undefined)\r\n    }\r\n    var first = <i32>load<u16>(\r\n      changetype<usize>(this) + (<usize>pos << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) {\r\n      return first;\r\n    }\r\n    var second = <i32>load<u16>(\r\n      changetype<usize>(this) + ((<usize>pos + 1) << 1),\r\n      HEADER_SIZE\r\n    );\r\n    if (second < 0xDC00 || second > 0xDFFF) return first;\r\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\r\n  }\r\n\r\n  @operator(\"+\")\r\n  private static __concat(left: String, right: String): String {\r\n    if (!changetype<usize>(left)) left = changetype<String>(\"null\");\r\n    return left.concat(right);\r\n  }\r\n\r\n  concat(other: String): String {\r\n    assert(this !== null);\r\n    if (other === null) other = changetype<String>(\"null\");\r\n    var thisLen: isize = this.length;\r\n    var otherLen: isize = other.length;\r\n    var outLen: usize = thisLen + otherLen;\r\n    if (outLen == 0) return EMPTY;\r\n    var out = allocate(outLen);\r\n\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE,\r\n      thisLen << 1\r\n    );\r\n\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE + (thisLen << 1),\r\n      changetype<usize>(other) + HEADER_SIZE,\r\n      otherLen << 1\r\n    );\r\n\r\n    return out;\r\n  }\r\n\r\n  endsWith(searchString: String, endPosition: i32 = MAX_LENGTH): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) return false;\r\n    var end = clamp<isize>(endPosition, 0, this.length);\r\n    var searchLength: isize = searchString.length;\r\n    var start: isize = end - searchLength;\r\n    if (start < 0) return false;\r\n    return !compare_memory(\r\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\r\n      changetype<usize>(searchString) + HEADER_SIZE,\r\n      searchLength << 1\r\n    );\r\n  }\r\n\r\n  @operator(\"==\")\r\n  private static __eq(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength = left.length;\r\n    if (leftLength != right.length) return false;\r\n\r\n    return !compare_memory(\r\n      changetype<usize>(left) + HEADER_SIZE,\r\n      changetype<usize>(right) + HEADER_SIZE,\r\n      (<usize>leftLength << 1)\r\n    );\r\n  }\r\n\r\n  @operator(\"!=\")\r\n  private static __ne(left: String, right: String): bool {\r\n    return !this.__eq(left, right);\r\n  }\r\n\r\n  @operator(\">\")\r\n  private static __gt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return false;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compare_memory(\r\n      changetype<usize>(left)  + HEADER_SIZE,\r\n      changetype<usize>(right) + HEADER_SIZE,\r\n      length << 1\r\n    ) > 0;\r\n  }\r\n\r\n  @operator(\">=\")\r\n  private static __gte(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!leftLength)  return !rightLength;\r\n    if (!rightLength) return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compare_memory(\r\n      changetype<usize>(left)  + HEADER_SIZE,\r\n      changetype<usize>(right) + HEADER_SIZE,\r\n      length << 1\r\n    ) >= 0;\r\n  }\r\n\r\n  @operator(\"<\")\r\n  private static __lt(left: String, right: String): bool {\r\n    if (left === right || left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return false;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compare_memory(\r\n      changetype<usize>(left)  + HEADER_SIZE,\r\n      changetype<usize>(right) + HEADER_SIZE,\r\n      length << 1\r\n    ) < 0;\r\n  }\r\n\r\n  @operator(\"<=\")\r\n  private static __lte(left: String, right: String): bool {\r\n    if (left === right) return true;\r\n    if (left === null || right === null) return false;\r\n\r\n    var leftLength  = left.length;\r\n    var rightLength = right.length;\r\n\r\n    if (!rightLength) return !leftLength;\r\n    if (!leftLength)  return true;\r\n\r\n    var length = <usize>min<i32>(leftLength, rightLength);\r\n    return compare_memory(\r\n      changetype<usize>(left)  + HEADER_SIZE,\r\n      changetype<usize>(right) + HEADER_SIZE,\r\n      length << 1\r\n    ) <= 0;\r\n  }\r\n\r\n  includes(searchString: String, position: i32 = 0): bool {\r\n    return this.indexOf(searchString, position) != -1;\r\n  }\r\n\r\n  indexOf(searchString: String, fromIndex: i32 = 0): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return 0;\r\n    var len: isize = this.length;\r\n    if (!len) return -1;\r\n    var start = clamp<isize>(fromIndex, 0, len);\r\n    len -= searchLen;\r\n    // TODO: multiple char codes\r\n    for (let k: isize = start; k <= len; ++k) {\r\n      if (!compare_memory(\r\n        changetype<usize>(this) + HEADER_SIZE + (k << 1),\r\n        changetype<usize>(searchString) + HEADER_SIZE,\r\n        searchLen << 1\r\n      )) {\r\n        return <i32>k;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  lastIndexOf(searchString: String, fromIndex: i32 = i32.MAX_VALUE): i32 {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n    var len: isize = this.length;\r\n    var searchLen: isize = searchString.length;\r\n    if (!searchLen) return len;\r\n    if (!len) return -1;\r\n    var start = clamp<isize>(fromIndex, 0, len - searchLen);\r\n\r\n    // TODO: multiple char codes\r\n    for (let k = start; k >= 0; --k) {\r\n      if (!compare_memory(\r\n        changetype<usize>(this) + HEADER_SIZE + (k << 1),\r\n        changetype<usize>(searchString) + HEADER_SIZE,\r\n        searchLen << 1\r\n      )) {\r\n        return <i32>k;\r\n      }\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  startsWith(searchString: String, position: i32 = 0): bool {\r\n    assert(this !== null);\r\n    if (searchString === null) searchString = changetype<String>(\"null\");\r\n\r\n    var pos: isize = position;\r\n    var len: isize = this.length;\r\n    var start = clamp<isize>(pos, 0, len);\r\n    var searchLength: isize = searchString.length;\r\n    if (searchLength + start > len) {\r\n      return false;\r\n    }\r\n    return !compare_memory(\r\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\r\n      changetype<usize>(searchString) + HEADER_SIZE,\r\n      searchLength << 1\r\n    );\r\n  }\r\n\r\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var intStart: isize = start;\r\n    var end: isize = length;\r\n    var size: isize = this.length;\r\n    if (intStart < 0) {\r\n      intStart = max<isize>(size + intStart, 0);\r\n    }\r\n    var resultLength = clamp<isize>(end, 0, size - intStart);\r\n    if (resultLength <= 0) {\r\n      return EMPTY;\r\n    }\r\n    var out = allocate(resultLength);\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE + (intStart << 1),\r\n      <usize>resultLength << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\r\n    assert(this !== null);\r\n    var len = this.length;\r\n    var finalStart = clamp<isize>(start, 0, len);\r\n    var finalEnd = clamp<isize>(end, 0, len);\r\n    var from = min<i32>(finalStart, finalEnd);\r\n    var to = max<i32>(finalStart, finalEnd);\r\n    len = to - from;\r\n    if (!len) {\r\n      return EMPTY;\r\n    }\r\n    if (!from && to == this.length) {\r\n      return this;\r\n    }\r\n    var out = allocate(len);\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE + (from << 1),\r\n      len << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  trim(): String {\r\n    assert(this !== null);\r\n    var length: usize = this.length;\r\n\r\n    while (\r\n      length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (length << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --length;\r\n    }\r\n    var start: usize = 0;\r\n    while (\r\n      start < length &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start, --length;\r\n    }\r\n    if (!length) {\r\n      return EMPTY;\r\n    }\r\n    if (!start && length == this.length) {\r\n      return this;\r\n    }\r\n    var out = allocate(length);\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\r\n      length << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  trimLeft(): String {\r\n    assert(this !== null);\r\n    var start: isize = 0;\r\n    var len: isize = this.length;\r\n    while (\r\n      start < len &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (start << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      ++start;\r\n    }\r\n    if (!start) {\r\n      return this;\r\n    }\r\n    var outLen = len - start;\r\n    if (!outLen) {\r\n      return EMPTY;\r\n    }\r\n    var out = allocate(outLen);\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE + (start << 1),\r\n      outLen << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  trimRight(): String {\r\n    assert(this !== null);\r\n    var len: isize = this.length;\r\n    while (\r\n      len > 0 &&\r\n      isWhiteSpaceOrLineTerminator(\r\n        load<u16>(changetype<usize>(this) + (len << 1), HEADER_SIZE)\r\n      )\r\n    ) {\r\n      --len;\r\n    }\r\n    if (len <= 0) {\r\n      return EMPTY;\r\n    }\r\n    if (<i32>len == this.length) {\r\n      return this;\r\n    }\r\n    var out = allocate(len);\r\n    move_memory(\r\n      changetype<usize>(out) + HEADER_SIZE,\r\n      changetype<usize>(this) + HEADER_SIZE,\r\n      len << 1\r\n    );\r\n    return out;\r\n  }\r\n\r\n  repeat(count: i32 = 0): String {\r\n    assert(this !== null);\r\n    var length = this.length;\r\n\r\n    // Most browsers can't handle strings 1 << 28 chars or longer\r\n    if (count < 0 || length * count > (1 << 28)) {\r\n      throw new RangeError(\"Invalid count value\");\r\n    }\r\n\r\n    if (count === 0 || !length) return EMPTY;\r\n    if (count === 1) return this;\r\n\r\n    var result = allocate(length * count);\r\n    var strLen = length << 1;\r\n\r\n    /*\r\n     * TODO possible improvments: reuse existing result for exponentially concats like:\r\n     * 'a' + 'a' => 'aa' + 'aa' => 'aaaa' + 'aaaa' etc\r\n     */\r\n    for (let offset = 0, len = strLen * count; offset < len; offset += strLen) {\r\n      move_memory(\r\n        changetype<usize>(result) + HEADER_SIZE + offset,\r\n        changetype<usize>(this)   + HEADER_SIZE,\r\n        strLen\r\n      );\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  toString(): String {\r\n    return this;\r\n  }\r\n\r\n  get lengthUTF8(): i32 {\r\n    var len = 1; // null terminated\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    while (pos < end) {\r\n      let c = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c < 128) {\r\n        len += 1; ++pos;\r\n      } else if (c < 2048) {\r\n        len += 2; ++pos;\r\n      } else {\r\n        if (\r\n          (c & 0xFC00) == 0xD800 && pos + 1 < end &&\r\n          (<u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE) & 0xFC00) == 0xDC00\r\n        ) {\r\n          len += 4; pos += 2;\r\n        } else {\r\n          len += 3; ++pos;\r\n        }\r\n      }\r\n    }\r\n    return len;\r\n  }\r\n\r\n  toUTF8(): usize {\r\n    var buf = allocate_memory(<usize>this.lengthUTF8);\r\n    var pos: usize = 0;\r\n    var end = <usize>this.length;\r\n    var off: usize = 0;\r\n    while (pos < end) {\r\n      let c1 = <u32>load<u16>(changetype<usize>(this) + (pos << 1), HEADER_SIZE);\r\n      if (c1 < 128) {\r\n        store<u8>(buf + off, c1);\r\n        ++off; ++pos;\r\n      } else if (c1 < 2048) {\r\n        let ptr = buf + off;\r\n        store<u8>(ptr, c1 >> 6      | 192);\r\n        store<u8>(ptr, c1      & 63 | 128, 1);\r\n        off += 2; ++pos;\r\n      } else {\r\n        let ptr = buf + off;\r\n        if ((c1 & 0xFC00) == 0xD800 && pos + 1 < end) {\r\n          let c2 = <u32>load<u16>(changetype<usize>(this) + ((pos + 1) << 1), HEADER_SIZE);\r\n          if ((c2 & 0xFC00) == 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            store<u8>(ptr, c1 >> 18      | 240);\r\n            store<u8>(ptr, c1 >> 12 & 63 | 128, 1);\r\n            store<u8>(ptr, c1 >> 6  & 63 | 128, 2);\r\n            store<u8>(ptr, c1       & 63 | 128, 3);\r\n            off += 4; pos += 2;\r\n            continue;\r\n          }\r\n        }\r\n        store<u8>(ptr, c1 >> 12      | 224);\r\n        store<u8>(ptr, c1 >> 6  & 63 | 128, 1);\r\n        store<u8>(ptr, c1       & 63 | 128, 2);\r\n        off += 3; ++pos;\r\n      }\r\n    }\r\n    store<u8>(buf + off, 0);\r\n    return buf;\r\n  }\r\n}\r\n\r\nexport function parseInt(str: String, radix: i32 = 0): f64 {\r\n  return parse<f64>(str, radix);\r\n}\r\n\r\nexport function parseI32(str: String, radix: i32 = 0): i32 {\r\n  return parse<i32>(str, radix);\r\n}\r\n\r\nexport function parseI64(str: String, radix: i32 = 0): i64 {\r\n  return parse<i64>(str, radix);\r\n}\r\n\r\n// FIXME: naive implementation\r\nexport function parseFloat(str: String): f64 {\r\n  var len: i32 = str.length;\r\n  if (!len) {\r\n    return NaN;\r\n  }\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: f64;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) {\r\n      return NaN;\r\n    }\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) {\r\n      return NaN;\r\n    }\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // calculate value\r\n  var num: f64 = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code == CharCode.DOT) {\r\n      ptr += 2;\r\n      let fac: f64 = 0.1; // precision :(\r\n      while (len--) {\r\n        code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n        if (code == CharCode.E || code == CharCode.e) {\r\n          assert(false); // TODO\r\n        }\r\n        code -= CharCode._0;\r\n        if (<u32>code > 9) {\r\n          break;\r\n        }\r\n        num += <f64>code * fac;\r\n        fac *= 0.1;\r\n        ptr += 2;\r\n      }\r\n      break;\r\n    }\r\n    code -= CharCode._0;\r\n    if (<u32>code >= 10) {\r\n      break;\r\n    }\r\n    num = (num * 10) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","import {\r\n  MAX_SIZE_32\r\n} from \"./allocator\";\r\n\r\nimport {\r\n  String\r\n} from \"../string\";\r\n\r\n/** Size of a String header. */\r\nexport const HEADER_SIZE = (offsetof<String>() + 1) & ~1; // 2 byte aligned\r\n\r\n/** Maximum length of a String. */\r\nexport const MAX_LENGTH = (<i32>MAX_SIZE_32 - HEADER_SIZE) >>> 1;\r\n\r\n/** Singleton empty String. */\r\nexport const EMPTY = changetype<String>(\"\"); // TODO: is this a bad idea with '===' in place?\r\n\r\n@inline\r\nexport function clamp<T>(val: T, lo: T, hi: T): T {\r\n  return max<T>(min<T>(val, hi), lo);\r\n}\r\n\r\n/** Allocates a raw String with uninitialized contents. */\r\nexport function allocate(length: i32): String {\r\n  assert(length > 0 && length <= MAX_LENGTH);\r\n  var buffer = allocate_memory(HEADER_SIZE + (<usize>length << 1));\r\n  store<i32>(buffer, length);\r\n  return changetype<String>(buffer);\r\n}\r\n\r\nexport function isWhiteSpaceOrLineTerminator(c: u16): bool {\r\n  switch (c) {\r\n    case 10:      // <LF>\r\n    case 13:      // <CR>\r\n    case 8232:    // <LS>\r\n    case 8233:    // <PS>\r\n    case 9:       // <TAB>\r\n    case 11:      // <VT>\r\n    case 12:      // <FF>\r\n    case 32:      // <SP>\r\n    case 160:     // <NBSP>\r\n    case 65279: { // <ZWNBSP>\r\n      return true;\r\n    }\r\n    default: return false;\r\n  }\r\n}\r\n\r\nexport const enum CharCode {\r\n  PLUS = 0x2B,\r\n  MINUS = 0x2D,\r\n  DOT = 0x2E,\r\n  _0 = 0x30,\r\n  _1 = 0x31,\r\n  _2 = 0x32,\r\n  _3 = 0x33,\r\n  _4 = 0x34,\r\n  _5 = 0x35,\r\n  _6 = 0x36,\r\n  _7 = 0x37,\r\n  _8 = 0x38,\r\n  _9 = 0x39,\r\n  A = 0x41,\r\n  B = 0x42,\r\n  E = 0x45,\r\n  O = 0x4F,\r\n  X = 0x58,\r\n  Z = 0x5a,\r\n  a = 0x61,\r\n  b = 0x62,\r\n  e = 0x65,\r\n  o = 0x6F,\r\n  x = 0x78,\r\n  z = 0x7A\r\n}\r\n\r\nexport function parse<T>(str: String, radix: i32 = 0): T {\r\n  var len: i32 = str.length;\r\n  if (!len) {\r\n    return <T>NaN;\r\n  }\r\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\r\n  var code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n\r\n  // determine sign\r\n  var sign: T;\r\n  if (code == CharCode.MINUS) {\r\n    if (!--len) {\r\n      return <T>NaN;\r\n    }\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = -1;\r\n  } else if (code == CharCode.PLUS) {\r\n    if (!--len) {\r\n      return <T>NaN;\r\n    }\r\n    code = <i32>load<u16>(ptr += 2, HEADER_SIZE);\r\n    sign = 1;\r\n  } else {\r\n    sign = 1;\r\n  }\r\n\r\n  // determine radix\r\n  if (!radix) {\r\n    if (code == CharCode._0 && len > 2) {\r\n      switch (<i32>load<u16>(ptr + 2, HEADER_SIZE)) {\r\n        case CharCode.B:\r\n        case CharCode.b: {\r\n          ptr += 4; len -= 2;\r\n          radix = 2;\r\n          break;\r\n        }\r\n        case CharCode.O:\r\n        case CharCode.o: {\r\n          ptr += 4; len -= 2;\r\n          radix = 8;\r\n          break;\r\n        }\r\n        case CharCode.X:\r\n        case CharCode.x: {\r\n          ptr += 4; len -= 2;\r\n          radix = 16;\r\n          break;\r\n        }\r\n        default: {\r\n          radix = 10;\r\n        }\r\n      }\r\n    } else radix = 10;\r\n  } else if (radix < 2 || radix > 36) {\r\n    return <T>NaN;\r\n  }\r\n\r\n  // calculate value\r\n  var num: T = 0;\r\n  while (len--) {\r\n    code = <i32>load<u16>(ptr, HEADER_SIZE);\r\n    if (code >= CharCode._0 && code <= CharCode._9) {\r\n      code -= CharCode._0;\r\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\r\n      code -= CharCode.A - 10;\r\n    } else if (code >= CharCode.a && code <= CharCode.z) {\r\n      code -= CharCode.a - 10;\r\n    } else {\r\n      break;\r\n    }\r\n    if (code >= radix) {\r\n      break;\r\n    }\r\n    num = (num * radix) + code;\r\n    ptr += 2;\r\n  }\r\n  return sign * num;\r\n}\r\n","function copy_memory(dest: usize, src: usize, n: usize): void {\r\n  // based on musl's implementation of memcpy\r\n  // not a future instruction and sufficiently covered by the upcoming move_memory intrinsic\r\n\r\n  var w: u32, x: u32;\r\n\r\n  // copy 1 byte each until src is aligned to 4 bytes\r\n  while (n && (src & 3)) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    n--;\r\n  }\r\n\r\n  // if dst is aligned to 4 bytes as well, copy 4 bytes each\r\n  if ((dest & 3) == 0) {\r\n    while (n >= 16) {\r\n      store<u32>(dest     , load<u32>(src     ));\r\n      store<u32>(dest +  4, load<u32>(src +  4));\r\n      store<u32>(dest +  8, load<u32>(src +  8));\r\n      store<u32>(dest + 12, load<u32>(src + 12));\r\n      src += 16; dest += 16; n -= 16;\r\n    }\r\n    if (n & 8) {\r\n      store<u32>(dest    , load<u32>(src    ));\r\n      store<u32>(dest + 4, load<u32>(src + 4));\r\n      dest += 8; src += 8;\r\n    }\r\n    if (n & 4) {\r\n      store<u32>(dest, load<u32>(src));\r\n      dest += 4; src += 4;\r\n    }\r\n    if (n & 2) { // drop to 2 bytes each\r\n      store<u16>(dest, load<u16>(src));\r\n      dest += 2; src += 2;\r\n    }\r\n    if (n & 1) { // drop to 1 byte\r\n      store<u8>(dest++, load<u8>(src++));\r\n    }\r\n    return;\r\n  }\r\n\r\n  // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\r\n  // doing shifts if faster when copying enough bytes (here: 32 or more)\r\n  if (n >= 32) {\r\n    switch (dest & 3) {\r\n      // known to be != 0\r\n      case 1: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 3;\r\n        while (n >= 17) {\r\n          x = load<u32>(src + 1);\r\n          store<u32>(dest, w >> 24 | x << 8);\r\n          w = load<u32>(src + 5);\r\n          store<u32>(dest + 4, x >> 24 | w << 8);\r\n          x = load<u32>(src + 9);\r\n          store<u32>(dest + 8, w >> 24 | x << 8);\r\n          w = load<u32>(src + 13);\r\n          store<u32>(dest + 12, x >> 24 | w << 8);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 2;\r\n        while (n >= 18) {\r\n          x = load<u32>(src + 2);\r\n          store<u32>(dest, w >> 16 | x << 16);\r\n          w = load<u32>(src + 6);\r\n          store<u32>(dest + 4, x >> 16 | w << 16);\r\n          x = load<u32>(src + 10);\r\n          store<u32>(dest + 8, w >> 16 | x << 16);\r\n          w = load<u32>(src + 14);\r\n          store<u32>(dest + 12, x >> 16 | w << 16);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        w = load<u32>(src);\r\n        store<u8>(dest++, load<u8>(src++));\r\n        n -= 1;\r\n        while (n >= 19) {\r\n          x = load<u32>(src + 3);\r\n          store<u32>(dest, w >> 8 | x << 24);\r\n          w = load<u32>(src + 7);\r\n          store<u32>(dest + 4, x >> 8 | w << 24);\r\n          x = load<u32>(src + 11);\r\n          store<u32>(dest + 8, w >> 8 | x << 24);\r\n          w = load<u32>(src + 15);\r\n          store<u32>(dest + 12, x >> 8 | w << 24);\r\n          src += 16; dest += 16; n -= 16;\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // copy remaining bytes one by one\r\n  if (n & 16) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 8) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 4) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 2) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n  if (n & 1) {\r\n    store<u8>(dest++, load<u8>(src++));\r\n  }\r\n}\r\n\r\nexport function move_memory(dest: usize, src: usize, n: usize): void {\r\n  // based on musl's implementation of memmove\r\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\r\n\r\n  if (dest == src) return;\r\n  if (src + n <= dest || dest + n <= src) {\r\n    copy_memory(dest, src, n);\r\n    return;\r\n  }\r\n  if (dest < src) {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while (dest & 7) {\r\n        if (!n) return;\r\n        --n;\r\n        store<u8>(dest++, load<u8>(src++));\r\n      }\r\n      while (n >= 8) {\r\n        store<u64>(dest, load<u64>(src));\r\n        n    -= 8;\r\n        dest += 8;\r\n        src  += 8;\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest++, load<u8>(src++));\r\n      --n;\r\n    }\r\n  } else {\r\n    if ((src & 7) == (dest & 7)) {\r\n      while ((dest + n) & 7) {\r\n        if (!n) return;\r\n        store<u8>(dest + --n, load<u8>(src + n));\r\n      }\r\n      while (n >= 8) {\r\n        n -= 8;\r\n        store<u64>(dest + n, load<u64>(src + n));\r\n      }\r\n    }\r\n    while (n) {\r\n      store<u8>(dest + --n, load<u8>(src + n));\r\n    }\r\n  }\r\n}\r\n\r\nexport function set_memory(dest: usize, c: u8, n: usize): void {\r\n  // based on musl's implementation of memset\r\n  // becomes obsolete once https://github.com/WebAssembly/bulk-memory-operations lands\r\n\r\n  // fill head and tail with minimal branching\r\n  if (!n) return;\r\n  store<u8>(dest, c);\r\n  store<u8>(dest + n - 1, c);\r\n  if (n <= 2) return;\r\n\r\n  store<u8>(dest + 1, c);\r\n  store<u8>(dest + 2, c);\r\n  store<u8>(dest + n - 2, c);\r\n  store<u8>(dest + n - 3, c);\r\n  if (n <= 6) return;\r\n  store<u8>(dest + 3, c);\r\n  store<u8>(dest + n - 4, c);\r\n  if (n <= 8) return;\r\n\r\n  // advance pointer to align it at 4-byte boundary\r\n  var k: usize = -dest & 3;\r\n  dest += k;\r\n  n -= k;\r\n  n &= -4;\r\n\r\n  var c32: u32 = <u32>-1 / 255 * c;\r\n\r\n  // fill head/tail up to 28 bytes each in preparation\r\n  store<u32>(dest, c32);\r\n  store<u32>(dest + n - 4, c32);\r\n  if (n <= 8) return;\r\n  store<u32>(dest + 4, c32);\r\n  store<u32>(dest + 8, c32);\r\n  store<u32>(dest + n - 12, c32);\r\n  store<u32>(dest + n - 8, c32);\r\n  if (n <= 24) return;\r\n  store<u32>(dest + 12, c32);\r\n  store<u32>(dest + 16, c32);\r\n  store<u32>(dest + 20, c32);\r\n  store<u32>(dest + 24, c32);\r\n  store<u32>(dest + n - 28, c32);\r\n  store<u32>(dest + n - 24, c32);\r\n  store<u32>(dest + n - 20, c32);\r\n  store<u32>(dest + n - 16, c32);\r\n\r\n  // align to a multiple of 8\r\n  k = 24 + (dest & 4);\r\n  dest += k;\r\n  n -= k;\r\n\r\n  // copy 32 bytes each\r\n  var c64: u64 = <u64>c32 | (<u64>c32 << 32);\r\n  while (n >= 32) {\r\n    store<u64>(dest, c64);\r\n    store<u64>(dest + 8, c64);\r\n    store<u64>(dest + 16, c64);\r\n    store<u64>(dest + 24, c64);\r\n    n -= 32;\r\n    dest += 32;\r\n  }\r\n}\r\n\r\nexport function compare_memory(vl: usize, vr: usize, n: usize): i32 {\r\n  // based on musl's implementation of memcmp\r\n  // provided because there's no proposed alternative\r\n  if (vl == vr) return 0;\r\n  while (n && load<u8>(vl) == load<u8>(vr)) {\r\n    n--;\r\n    vl++;\r\n    vr++;\r\n  }\r\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\r\n}\r\n"]}